{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang3082{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sl240\slmult1\f0\fs22\lang10 crear carpeta proyecto\par
\par
\b\fs28 AUTH\fs22\par
\b0\par
crear carpeta de primer servicio\par
creo archivo json base \par
\par
> npm init -y\par
\par
dentro activar typescript y sus tipos:\par
\par
> npm install typescript ts-node-dev express @types/express\par
\par
creo el archivo de config inicial\par
\par
> tsc --init\par
\par
dentro creo carpeta -> src y dentro archivo base -> index.ts (ts por typescript no js)\par
\par
code:\par
\par
import express from "express";\par
import \{ json \} from "body-parser";\par
\par
const app = express();\par
app.use(json());\par
\par
app.listen(3000, () => \{\par
  console.log("Listening on port 3000!");\par
\});\par
\par
---\par
\par
1) plantilla base\par
2) define puerta para escuchar los\par
\par
en el packagejson buscar linea y modificar el script de 'start'\par
\par
"start": "ts-node-dev src/index.ts"\par
\par
en la consola podemos probarf con:\par
\par
npm start \par
\par
debe aparecer el mensaje "escuchando la puerta...!!"\par
\par
creamos archivo dockerfile:\par
\par
FROM node:alpine\par
\par
WORKDIR /app\par
COPY package.json .\par
RUN npm install --only=prod\par
COPY . .\par
\par
CMD ["npm", "start"]\par
\par
y creamos el archivo .dockerignore\par
agregamos dentro\par
node_modules\par
\par
para no subir esos archivos\par
\par
nota: (check: "ts-node-dev": "^2.0.0",    -> sino cambiar para q se actualice)\par
\par
desde la carpeta auth ejecutamos:\par
docker build -t nombre_cuenta_docker/servicios .    (el punto es cr\'edtico)\par
\par
el script corre y env\'eda mensaje que imagen ha sido construida.!\par
\par
\ul\b kubernete cluster config \par
\ulnone\b0\par
ahora creamos una carpeta dentro de proyecto\par
\par
> infra \par
(de infraestrucutra y dentro  carpeta )\par
> k8s\par
\par
con nombre auth-depl.yaml :\par
\par
apiVersion: apps/v1\par
kind: Deployment\par
metadata:\par
  name: auth-depl\par
spec:\par
  replicas: 1\par
  selector:\par
    matchLabels:\par
      app: auth\par
  template:\par
    metadata:\par
      labels:\par
        app: auth\par
    spec:\par
      containers:\par
        - name: auth\par
          image: danilousach/auth\par
          env:\par
            - name: MONGO_URI\par
              value: 'mongodb://auth-mongo-srv:27017/auth'\par
            - name: JWT_KEY\par
              valueFrom:\par
                secretKeyRef:\par
                  name: jwt-secret\par
                  key: JWT_KEY\par
---\par
apiVersion: v1\par
kind: Service\par
metadata:\par
  name: auth-srv\par
spec:\par
  selector:\par
    app: auth\par
  ports:\par
    - name: auth\par
      protocol: TCP\par
      port: 3000\par
      targetPort: 3000\par
\par
con estos par\'e1metros se construye le scrpit para realizar varios pasos:\par
\par
despliegue con \'faltimas 'latest' tag asociada en el pod:\par
hago cambio de code \par
construyo la imagen\par
push la imagen a docker hub\par
correr el comando kubectl rollout restart deployment nombre\par
\par
para automatizar usamos el line de comando:\par
\par
\b skaffold\b0\par
\par
automatiza muchas tareas del ambiente  kubernetes \par
facilita la actualizaci\'f3n de c\'f3digo en pod en ejecuci\'f3n\par
facilita la creaci\'f3n o borrado de todos los objetos asociados a un proyecto\par
\par
visite: {{\field{\*\fldinst{HYPERLINK https://skaffold.dev/ }}{\fldrslt{https://skaffold.dev/\ul0\cf0}}}}\f0\fs22\par
\par
se instala descargando el bin y se agrega en las variables de ambiente de win, en el  path como skaffold.exe\par
\par
(tambi\'e9n existe la forma de instalar primero chocolatey y luego instalar desde ese admin de paquetes)\par
\par
luego para chequwear todo ok\par
en la carpeta ra\'edz del proyecto debe correr:\par
skaffold\par
\par
y aparece la info de ayuda.\par
\par
(un tema puede ser el uso de las puertas, en el ejemplo inicial usamos la puerta 80 y estaba ocupada por otro servicio W3SVC o USERV tengo q cambiar la config de iniciar auto a preguntar o nunca)\par
\par
\par
creamos un archivo 'skaffold' que se encarga de automatizar los procesos de revisi\'f3n de cambios del code, cambios en la infra en los yaml y automaticamente crea el proceso para la actualziaci\'f3n en el cluster  y config de kubernetes:\par
\par
creamos archivo:\par
\par
> skaffold.yaml\par
\par
apiVersion: skaffold/v2alpha3\par
kind: Config\par
deploy:\par
  kubectl:\par
    manifests:\par
      - ./infra/k8s/*\tab\tab\tab\tab <- procea tondo dentro de esa carpeta\par
build:\par
  local:\par
    push: false\par
  artifacts:\par
    - image: danilousach/auth \tab\tab <- usuario kubernete/nombre_servicio\par
      context: auth\tab\tab\tab\tab\tab <- mismo nombre de carpeta servicio\par
      docker:\par
        dockerfile: Dockerfile\tab\tab <- ojo D may\'fascula\par
      sync:\par
        manual:\par
          - src: "src/**/*.ts"\tab\tab <- sincronizar todos los .ts dentro de las carpetas dentro de src\par
            dest: .\tab\tab\tab\tab\tab <- dejarlas en su misma posici\'f3n relativa en el pods\par
\par
\par
\par
\par
agregar npm validador de correo y otros\par
\par
> npm install express-validator\par
\par
\par
\par
corregir conexi\'f3n a puerto:\par
\par
check si esta arriba gninx:\par
kubectl get namespace\par
buscar:\par
ingress-nginx  \par
\par
\par
kubectl delete namespace ingress-nginx\par
\par
\par
kubectl apply -f {{\field{\*\fldinst{HYPERLINK https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml }}{\fldrslt{https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.0/deploy/static/provider/cloud/deploy.yaml\ul0\cf0}}}}\f0\fs22\par
\par
\par
cada cambio de code:\par
\par
-------------------------------\par
\par
docker build -t danilousach/auth .\par
\par
docker push danilousach/auth\par
\par
-------------------------\par
\par
\par
\par
seguimos gestioanndo los errores\par
\par
ahora:\par
\par
> npm install express-async-errors\par
\par
\par
luego de organizar los errores y crear el primer middleware vamos a almacenar los correos en base de datos mongoDB mediante el archivo de deploy yaml. \par
\par
check \par
> kubectl get pods\par
\par
debe aparece algo como:\par
auth-mongo-depl-68d46f5c4c-vvwsj   1/1     Running   0          3m34s\par
\par
instalamos conexi\'f3n\par
\par
npm install mongoose\par
npm install @types/mongoose\par
\par
\par
se almacena en bd ahora se trabaja con las cookies y para almacenar un id de conectado\par
\par
> npm install cookie-session @types/cookie-session\par
\par
para convertir los datos en un token json y poder esconder la data:\par
\par
> npm install jsonwebtoken @types/jsonwebtoken\par
\par
usamos una clave convertido y almacernada en un pods:\par
\par
> kubectl create secret generic jwt-secret --from-literal=JWT_KEY=asdf\par
\par
check\par
\par
kubectl get secrets\par
\par
modificamos el auth-depl.yaml para agregar la clave:\par
\par
env:\par
  - name: JWT_KEY\par
    valueFrom:\par
      secretKeyRef:\par
        name: jwt-secret\par
        key: JWT_KEY\par
\par
\par
tenemos listo el servicio de auth y login, ahora pasamos a las pruebas unitarias por servicios, para ello vamos a instalar m\'e1s dependencias\par
\par
npm install --save-dev @types/jest @types/supertest jest ts-jest supertest \par
\par
aparte, m\'e1s pesado\par
\par
npm install mongodb-memory-server\par
\par
\par
ojo: mongo-memory-server no esta en npm y se debe descargar aparte, no es necesario pero ayuda + r\'e1pido test\par
\par
para no estar pasando los archivos en cada skaffold, se modifica el Dockerfile a :\par
\par
RUN npm install --omit=dev\par
\par
no usa nada de test...\par
\par
\par
puede generar problemas de compatibilidad!!\par
\par
ojo\par
\par
resolver igualando las versiones:\par
\par
"devDependencies": \{\par
    "@types/jest": "^27.1.5",    <-----------\par
    "@types/supertest": "^2.0.12",\par
    "jest": "^27.5.1",\par
    "supertest": "^6.2.4",\par
    "ts-jest": "^27.1.5"              <-----------------\par
\par
    NO OLVIDAR ARREGLOS EN VIDEO 200 AL MPNGOMEMORYSERVER\par
\par
    se debe modificar package.json para agregar los script de pruebas,\par
\par
    debe quedar:\par
\par
    "scripts": \{\par
    "start": "ts-node-dev src/index.ts",\par
    "test": "jest --watchAll --no-cache"\par
  \},\par
  "jest": \{\par
    "preset": "ts-jest",\par
    "testEnvironment": "node",\par
    "setupFilesAfterEnv": [\par
      "./src/test/setup.ts"\par
    ]\par
  \},\par
\par
\par
\par
  para probar y luego de crear las carpetas 'test' y '__test__' con los script se ejecuta todo en la consola \par
\par
  npm run test\par
\par
  queda corriendo atento a cambios o nuevos test, todos tienen estructura\par
\par
  it('mensaje', foo);\par
\par
  pueden existir problemas porque no detectar\'eda los cambios... control + c y probar nuevamente...\par
\par
  -------------------------------------\par
\par
  empezamos con el client\par
\par
  en root \par
\par
  mkdir client\par
  cd client\par
  npm init -y\par
\par
luego los componentes\par
\par
npm install react react-dom next\par
\par
en carpeta crear \par
\par
mkdir pages\par
\par
carpeta especial, cada archivo js ser\'e1 una pagina web \par
\par
se han creado varios archivo, editar package.json, para agregar el script q permite levantar web\par
\par
debe quedar as\'ed:\par
\par
\par
  "scripts": \{\par
    "dev": "next"\par
\par
\par
luego, creo un archivo index.js y levanto \par
\par
npm run dev\par
\par
\par
compila y lanza aviso q est\'e1 disponible en:\par
\par
{{\field{\*\fldinst{HYPERLINK http://localhost:3000/ }}{\fldrslt{http://localhost:3000/\ul0\cf0}}}}\f0\fs22\par
\par
\par
voy con browser y se levanta!!!\par
\par
en la carpeta esta 'banana.js' un test\par
\par
si:\par
\par
{{\field{\*\fldinst{HYPERLINK http://localhost:3000/banana }}{\fldrslt{http://localhost:3000/banana\ul0\cf0}}}}\f0\fs22\par
\par
se levanta banana... cada file un pagina y ese es el link (su nombre)\par
\par
todo en m\'e1quina local...\par
\par
(OJO)\par
\par
ahora escribimos en js no TS porque Next se complica y aporta poco\par
en el server debe ser TS!!!\par
\par
para pasar a nuestros kubernete comenzamos\par
\par
creando dentro de la carpeta client nuestro \par
\par
Dockerfile\par
\par
con el texto:\par
\par
\par
\par
FROM node:alpine\par
\par
WORKDIR /app\par
COPY package.json .\par
RUN npm install\par
COPY . .\par
\par
CMD ["npm", "run", "dev"]\par
\par
\par
es MUY importante no estar subiendo la carga de modulos y paquetes ya que k8s se encarga,\par
para ello le avisamos mediante el archivo\par
\par
.dockerignore (sin extension y punto inicial)\par
\par
node_modules\par
.next\par
\par
q esas carpetas no se deben subir\par
\par
ahora empaquetamos en docker:\par
\par
docker build -t danilousach/client .   <- ese punto es importante q vaya\par
\par
luego se debe presionar (enviar a cloud)\par
\par
docker push danilousach/client\par
\par
ES MUY IMPORTANTE CORTAR SKAFFOLD MIENTRAS SUBES ESTA IMAGEN, GENERA ERRORES Y MENSAJE\par
\par
MEJOR ESPERA AL PUSH Y REINICIA SKAFFOLD DEV\par
\par
\par
no olvidar agregar en ingress-srv.yaml en el formato correcto el servicio:\par
\par
          - path: /?(.*)\par
            pathType: Prefix\par
            backend:\par
              service:\par
                name: client-srv\par
                port:\par
                  number: 3000\par
\par
\par
\par
ahora podemos ver la app en el pods o kubernete\par
\par
{{\field{\*\fldinst{HYPERLINK https://ticketing.dev/ }}{\fldrslt{https://ticketing.dev/\ul0\cf0}}}}\f0\fs22\par
\par
\par
OJO\par
\par
se puede bloquear por insegura, recuerda truco \par
\par
thisisunsafe\par
\par
ahora en el browser la pagina\par
\par
COSA LOCA\par
\par
edita el archivo js en vscode y se actualiza autom\'e1ticamente (si esta corriendo skaffold)\par
\par
PARA ASEGURAR EL REFRESH NO OLVIDAR AGREGAR O CREAR EL ARCHIVO\par
\par
next.config.js en client con:\par
\par
module.exports = \{\par
  webpackDevMiddleware: (config) => \{\par
    config.watchOptions.poll = 300;\par
    return config;\par
  \},\par
\};\par
\par
\par
aparece mensaje en skaffold que se debe reiniciar el server, para evitarlo y refrescar en caliente vamos a ver la lista de pods, buscar el delcliente, apagarlo y al reinicio autom\'e1tico tomar\'e1 la configuraci\'f3n de refresco mirando el proyecto! no el server...\par
\par
kubectl get pods\par
\par
client-depl-6979fdf775-jf82m (copiar de la lista)\par
\par
kubectl delete pod client-depl-6979fdf775-jf82m\par
\par
web dise\'f1o:\par
\par
debemos crear un archivo _app.js en la ra\'edz y solo all\'ed podemos colocar una librer\'eda universal al sistema\par
\par
usamos el sistema bootstrap, potente, liviano y muy vers\'e1til\par
\par
debemos agregar en carpeta cliente...\par
\par
npm install bootstrap\par
\par
\par
luego el sitio se puede caer, skaffold envia muchos mensajes, una joda pero al fin se actualiza solo con el nuevo dise\'f1o...\par
\par
\par
un manjarssss\par
\par
tenemos el sitio, dise\'f1amos el cuadro de dialo, ahora debemos ser capaces de recibir y enviar eventos o mensajes \par
\par
para ello existe el paquete\par
\par
\par
npm install axios\par
\par
\par
.\par
.\par
.\par
.\par
video 239\par
\par
extraer nombr de servicios corriendo en mi maquina\par
\par
kubectl get services -n ingress-nginx\par
\par
el nombr eq buscamos es:\par
\par
ingress-nginx-controller             LoadBalancer   10.97.93.53      localhost     80:31454/TCP,443:31019/TCP \par
  12h\par
\par
\par
....\par
256\par
\par
construimos paquete common para subir a npm\par
\par
crear una libreria comun, en root\par
\par
mkdir common\par
cd common\par
npm init -y\par
\par
lo primero ajustar el package.json, nombre y version\par
as\'ed:\par
\par
"name": "@dynacodex/common-v2",\par
  "version": "1.0.0",\par
\par
\par
nombre dynacodex es la cuenta en npmjs.com....\par
\par
(debe tener instalado y corriendo git en su m\'e1quina para lo q seigue)\par
\par
en common\par
\par
git init\par
git add .\par
git commit -m "commit inicial"\par
\par
(empaquetamos todos los archivos y preparamos la primera subida...)\par
\par
en lka web npmjs.com ya estamos registrados y logeados con cuenta publica (gratis) podemos enviar directo de la consola, si no estamos logeados en consola:\par
\par
npm login\par
username: XXXXXX digitar el de la cuenta\par
passwors: XXXXXX no se ve, confiar\par
\par
\par
luego \par
\par
npm publish --access public\par
\par
vas a mirar al sitio y aparece tu package...\par
\par
ahora, vamos a preparar alguna dependencias porque vamos a escribir en ts pero se publica en js.\par
\par
dentro de common\par
\par
tsc --init\par
(se crea un archivo tsconfig.json)\par
\par
npm install typescript del-cli --save-dev\par
(se crean como dependencias de desarrollo, u item especial en el json)\par
\par
ahora TEST 1 ---------------------\par
mkdir src\par
\par
dentro creamos index.ts\par
\par
colocamos algo de c\'f3digo ts para ver la conversion a js y ciclo:\par
\par
interface Color \{\par
  red: number;\par
  blue: number;\par
  green: number;\par
\}\par
\par
const color: Color = \{\par
  red: 10,\par
  blue: 10,\par
  green: 10\par
\};\par
\par
console.log(color);\par
\par
\par
ojo\par
en archivo tsconfig.json vamos a cambiar a:\par
\par
    // "checkJs": true,                       /* Report errors in .js files. */\par
    // "jsx": "preserve",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */\par
    "declaration": true /* Generates corresponding '.d.ts' file. */,\par
    // "declarationMap": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */\par
    // "sourceMap": true,                     /* Generates corresponding '.map' file. */\par
\par
\par
tambi\'e9n:\par
\par
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\par
   "outDir": "./build",                                   /* Specify an output folder for all emitted files. */\par
    // "removeComments": true,                           /* Disable emitting comments. */\par
\par
\par
    ok, aceptamos ts y la compilaci\'f3n queda en la carpeta build...\par
\par
    ahora modificamos package.json para DECLARAR el script y estas opciones:\par
\par
debe quedar asi la secci\'f3n:\par
\par
    "scripts": \{\par
    "build": "tsc"\par
  \},\par
\par
\par
  luego desde la consola, vamos a correr el script para crear en la carpeta el c\'f3digo que agregamos en index.ts\par
\par
npm run build  \par
\par
aparece dentro de la carpeta buil los archivos ts y js....\par
\par
una mejora, cada vez q compilo se debe limpiar la carpeta para evitar cualquier problema, para ello automatizo el proceso con script consecutivos:\par
\par
as\'ed deve quedar la secci\'f3n script, simplemente agrego un 'clean' a la carpeta usando el comando 'del-cli' (as\'ed no pelea con el del de windows...y en el 'build' agrego previamente a la conversi\'f3n con tsc...\par
\par
**Ahora una nota respecto a la estructura de archivos, "main","types" y "files" que definen los archivos aimportar, su estructura de carpetas y extnsiones....\par
\par
\par
\par
"description": "",\par
  "main": "./build/index.js",\par
  "types": "./build/index.d.ts",\par
  "files": [\par
    "build/**/*"\par
  ],\par
  "scripts": \{\par
    "clean": "del-cli ./build/*",\par
    "build": "npm run clean && tsc",\par
    "pub": "git add . && git commit -m \\"Updates\\" && npm version patch && npm run build && npm publish"\par
  \},\par
\par
\par
\par
\par
otra acci\'f3n de limpieza dom\'e9stica \par
\par
creamos un archivo con nombre ".gitignore" dentro de common, comienza con punto y es git ignore, osea, contiene un listado de los elementos que no deseamos subir...\par
\par
vamos a agregar dentro de \'e9l a las carpetas\par
\par
build\par
node_modules\par
\par
\par
\par
ya,\par
\par
ahora vamos a continuar con el proceso de coding\par
\par
si hago un cambio en el index.ts y guardo se genera un cambio q se debe enviar v\'eda git a nuestro repo\par
\par
para chequear el estado usamos:\par
\par
git status\par
\par
y la secuencia para realmente actualizar y subir\par
\par
git init\par
git add .\par
git commit -m "commit adicional"\par
\par
si deseo avisar del cambio puedo realizar un cambio de versi\'f3n (recordar q dentro del archivo package.json) se indica:\par
\par
 "name": "@dynacodex/common-v2",\par
  "version": "1.0.0",\par
\par
\par
  entonces, luego del commit manual se puede actualziar v\'eda comando con:\par
\par
  npm version patch\par
\par
  (solo funciona si no tenemos commit pendientes)\par
\par
y se actualiza en el archivo, ahora construimos\par
\par
npm run build\par
\par
y publicamos en site\par
\par
npm publish --access public\par
\par
(si miramos la p\'e1gina web, encontramos la actualizaci\'f3n)\par
\par
como vemos es un mmont\'f3n de pasos, as\'ed q vamos a buscar una manera de simplifica...\par
\par
\par
agregamos un nuevo script, 'pub'\par
\par
"build": "npm run clean && tsc",  <-- nte la coma que agregamos \par
"pub": "git add . && git commit -m \\"Updates\\" && npm version patch && npm run build && npm publish --access public"\par
\par
\par
hacemos un cambio en el code, y ejecutamos\par
\par
npm run pub\par
\par
si vemos con atenci\'f3n los mensajes encontramos la nueva versi\'f3n \par
\par
--------------------------------\par
\par
devuelta al proyecto.\par
\par
acabamos de mover varias carpetas dentro (error y middleware)\par
\par
modificamos el index con los exports...\par
\par
vamos a chequear (siempre dentro de common)\par
\par
tsc\par
\par
vemos un mont\'f3n de errores!\par
\par
\par
son las dependencias q no se agregan...\par
\par
agregamos a mano:\par
\par
npm install express express-validator cookie-session jsonwebtoken @types/cookie-session @types/express @types/jsonwebtoken\par
\par
nuevamente intentamos:\par
\par
tsc\par
\par
y yep!!\par
\par
estamos listos para \par
\par
npm run pub\par
\par
\par
-------------------\par
\par
ahora tenemos el problema en la carpeta 'auth' donde sacamos las carpetas y perdieron un mont\'f3n de referencias, vamos a corregir importando nustro nuevo paquete..\par
\par
cambiamos a carpeta\par
\par
cd..\par
cd auth\par
npm install @dynacodex/common-v3\par
\par
(el nombre debe ser exacto el q agregamos en package.json en common)\par
\par
\par
ahora ordenadamente comenzar a recorrer todos los *.ts buscando errores de referencia y reemplazar \par
\par
por ejemplo:\par
\par
\par
import \{ currentUser \} from '../middlewares/current-user';\par
\par
a\par
(al escribir la arroba y la 'd' aparece la opci\'f3n, con tab acepta el resto)\par
\par
import \{ currentUser \} from '@dynacodex/common-v2';\par
\par
y as\'ed...\par
\par
(si tenemos skaffold corriendo en una terminal, debe aparecer como conectado a mongo y escuchando port 3000... y sin se\'f1ales de error)\par
\par
ahora tenemos nuestro sewrvicio auth referenciando nuestgro paquete npm, ahora nuerstro paquete se va actualizando y recibiendo mejoras, se sube al web y se actualiza la versi\'f3n, necesitamos MANTENER ACTUALZIADO NUESTROS SERVICIOS QUE HACEN REFERENCIA A \'c9L.\par
\par
  PARA ELLO vamos a trasbajar una secuencia de pasos:\par
\par
cd..\par
cd common\par
\par
  1) modifica el code de common (por ejemplo agrega un comentario: //bla bla bla)\par
  2) grabar y ejecutar \par
\par
npm run pub\par
\par
*toma nota de la versi\'f3n q entrega el proceso... mi caso 1.0.5.\par
\par
\par
actualizar los servicios q usan:\par
\par
cd..\par
cd auth\par
\par
npm update @dynacodex/common-v2 --save\par
\par
**problema: si vamos a mirar en el package.json no aparece la nueva versi\'f3n, si vemos dentro de carpeta 'node_modules' aparece la versi\'f3n m\'e1s actualizada...  ideas?\par
\par
\par
VEAMOS\par
\par
kubectl get pods\par
\par
buscamos auth-depl-...\par
\par
auth-depl-6d4557bdc6-72zzh\par
\par
miremos dentro\par
\par
kubectl exec -it auth-depl-6d4557bdc6-72zzh -- sh\par
\par
quedamos en modo shell (dentro de pods)\par
\par
# ls\par
\par
#cd node_modules\par
\par
#cd @dynacodexexit\par
\par
#ls\par
\par
#cd common-v2\par
\par
#cat package.json  (veo dentro del archivo)\par
\par
#exit \par
\par
-------------------------------------\par
\par
ahora se comienza con el nuevo evento\par
\par
tickets,\par
\par
se copia una serie de archivos y se reinstalan las dependencias, si existe choque de versions, adem\'e1s de remover la carpeta modulo y usar la versi\'f3n nueva de @dynacodex/common se hacen unos cambios muy espec\'edficos en src/test/setup.ts\par
\par
y construir:!\par
\par
docker build -t danilousach/tickets .\par
docker push danilousach/tickets\par
\par
lista la imagen docker ahora preparamos el deply kubernete\par
\par
ccreamos en infra/k8s tickets-depl.yaml y copiamos dentro todo el contenido de auth-depl.yaml\par
cambiar todos los auth por tickets\par
\par
tambien podemos copy paste y renombrar...\par
\par
auth-mongo... copiar a un tickets-mongo...\par
\par
NOTA:\par
\par
Se recomienda control C control C para reiniciar skaffold...\par
\par
\par
si arroja problemas o las imagenes no se cargan, mejor limpiar:\par
\par
skaffold delete\par
\par
skaffold dev\par
\par
y construir las imagenes con docker build y push en la carpeta del servicio.\par
\par
\par
un test: ver en skaffold:\par
[tickets] Connected to MongoDb\par
[tickets] Listening on port 3000!!!!!!!!\par
\par
--------------------------\par
buen momento para iniciar las pruebas de code para crear test.\par
se mantiene la esrtuctura de carpetas \par
routes/__test__/xxx.test.ts\par
\par
y se ejecutan con \par
\par
npm run test\par
\par
\par
-------------------------\par
\par
global debe quedar:\par
\par
declare global \{\par
  var signin: () => string[];\par
\}\par
\par
y al final de archivo checar q sea:\par
\par
  // return a string thats the cookie with the encoded data\par
  return [`session=$\{base64\}`];\par
\par
\par
-------------------------------------------------------------------------------\par
\par
modificamos un archivo en middleware y debemos reconstruir, subir a npm y actualizar los servicios\par
\par
\par
common\\npm run pub\par
\par
\par
tickets\\npm update @dynacodex/common-v3\par
\par
-------------------------------------------------------------\par
test manual\par
primero modificar el ingress-srv.yaml\par
\par
agregar servicio de tickets:\par
\par
- path: /api/user/?(.*)\par
            pathType: Prefix\par
            backend:\par
              service:\par
                name: tickets-srv\par
                port:\par
                  number: 3000\par
\par
*formato distitnto al del video (se actualiz\'f3)\par
                  (OJO siempre dejar \'faltimo el serviocio de cliente -React-)\par
\par
----------------------------------------------------\par
\par
implementaci\'f3n del bus de eventos NATS\par
\par
no confundir debe ser desde docker hub!!!!\par
\par
"nats-streaming"\par
y correr dentro de kubernetes!! porsi\par
----------------------------------------                  \par
\par
se crea un yaml correspondiente\par
\par
nats-depl\par
\par
al grabar skaffold construye y chequeamos con:\par
\par
kubectl get pods\par
\par
-----\par
creamos un proyecto de prueba para estudiar nats\par
\par
cd..\par
mkdir nats-test\par
npm init -y\par
npm install node-nats-streaming ts-node-dev typescript @types/node\par
\par
dentro carpeta src y creamos dos archivos publisher.ts y listener.ts\par
\par
lo primero modificar el package.json para ejecutar cada tipo:\par
\par
"scripts": \{\par
    "publish": "ts-node-dev --notify false src/publisher.ts",\par
    "listen": "ts-node-dev --notify false src/listener.ts"\par
  \},\par
\par
\par
dentro de carpeta nats-test\par
\par
tsc --init\par
npm install -g typescript\par
\par
chequear los pods corriendo\par
\par
kubectl get pods\par
\par
copiamos el q corresponde a nats:\par
\par
nats-depl-5bd9f6767b-scw2v\par
\par
componemos la sentencia:\par
\par
kubectl port-forward nats-depl-5bd9f6767b-scw2v 4222:4222\par
\par
debe responder:\par
\par
Forwarding from 127.0.0.1:4222 -> 4222\par
Forwarding from [::1]:4222 -> 4222\par
\par
significa q tengo una forma de escuchar desde fuera al pods mediante "ese puente"\par
\par
ahora para probar conexi\'f3n\par
\par
EN OTRA CONSOLA DENTRO DE nats-test\par
\par
npm run publish\par
\par
..debe aparecer el mensaje condola.log() que agruegue en publisher...\par
\par
\par
ojo:\par
\par
para poder reset se agrega comando en package\par
\par
"scripts": \{\par
  "publish": "ts-node-dev --rs --notify false src/publisher.ts",\par
  "listen": "ts-node-dev --rs --notify false src/listener.ts"\par
\},\par
\par
.\par
.\par
.\par
.\par
.\par
mucho codigo reordenando y pasamos al final de seccion 15:\par
\par
un pods puede estar muy lleno de datos volando, desordenado por las pruebas, se rinicia \par
\par
1) conseguir nombre\par
kubectl get pods\par
\par
2) se copia el nombre\par
\par
3) se borrar para q reinicio uno nuevo\par
kubectl delete pod nats-depl-5bd9f6767b-scw2v \par
\par
4) confirmar uno nuevo\par
kubectl get pods\par
\par
\par
ptrp \'b4rpblema fue un par\'e1metro en el tsconfig.json:\par
\par
"target": "es6", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */\par
\par
q impide q listener escuche el sitio...\par
\par
\par
------\par
orders\par
\par
copiados y modifcados los archivos\par
\par
error:\par
\par
 error when creating "STDIN"\par
\par
solo borrar:\par
kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission\par
\par
skaffold dev\par
\par
\par
\par
\par
---------------------------\par
\par
secci\'f3n 19\par
problema de concurrencia, asegurar la llegada en orden de los tickets\par
en carpeta tickets, ellos queremosd ordenar \par
\par
npm install mongoose-update-if-current\par
\par
\par
\par
--------------------\par
seccion 20\par
\par
no olvidar crear secreto en el pods\par
kubectl create secret generic stripe-secret --from-literal STRIPE_KEY=sk_test_51LPvZ2KmcQM0Ki8d7PAMz7rpJEzDUEgNhtQulGvwEFQJ6cQRUiDkXa5bRKORPBi9W8VRknUyYLZYNYa7RmHDggim00UH1imJv5\par
\par
\par
otro secreto:\par
kubectl create secret generic jwt-secret --from-literal JWT_KEY=asdf\par
\par
--------------------------\par
\par
reclama por componenetes, video 504:\par
\par
npm i prop-types\par
\par
\par
---------------------------------------\par
---------------------------------------\par
---------------------------------------\par
---------------------------------------\par
\par
implementacion cap 23\par
\par
---------------------------------------\par
---------------------------------------\par
---------------------------------------\par
\par
\par
\par
github\par
\par
dynageo@gmail.com\par
danilo00malloco\par
\par
git init \par
\par
crear .gitignore en carpeta ra\'edz\par
agregar dentro:\par
node_modules\par
\par
\par
en consola:\par
\par
git add .\par
git commit -m "commit inicial"\par
\par
ir a pagina github:\par
\par
crear repositorio\par
\par
luego copiar HTTPS de conexi\'f3n...\par
\par
volver a consola:\par
\par
git remote add origin <paste>\par
\par
git push origin master\par
\par
\par
regreso a web y F5 o refresh\par
\par
ver listado de folder y files\par
\par
\par
en action github actions:\par
\par
name: tests\par
on:\par
  pull_request:\par
jobs:\par
  build:\par
    runs-on: ubuntu-latest\par
    steps:\par
      - uses: actions/checkout@v2\par
      - run: cd auth/ && npm install && npm run test:ci\par
\par
--------------------------------------------\par
\par
modificar en /auth el package.json agregando el script:\par
"scripts": \{\par
    "start": "ts-node-dev src/index.ts",\par
    "test": "jest --watchAll --no-cache",\par
    "test:ci": "jest --forceExit --detectOpenHandles --maxWorkers=10"   <-----------\par
  \},\par
  \par
al grabar el cambio,\par
voy a consola y aplica:\par
\par
git status\par
\par
informa del cambio y pendiente para subir:\par
\par
git add .\par
git commit -m "agrego test en auth"\par
git push origin master\par
\par
problema:\par
\par
git pull origin master\par
\par
(merge)\par
\par
git push origin master\par
\par
ok!\par
\par
ahora vuelvo a code y modifica el code en auth\par
\par
subir cambio a ootro branch!!\par
\par
git checkout -b dev\par
\par
git status\par
(informa rama dev y cambio pendsiente por subir)\par
\par
\par
git add .\par
git commit -m "agrego mensaje start"\par
git push origin dev\par
\par
...\par
\par
ir a mirar en web "pull request"\par
\par
bot\'f3n verde "new pull request"\par
\par
master <- dev\par
\par
informa cambio, check verde listo para mezclar\par
\par
click en create pull request (verde)\par
puedo cambiar titulo\par
y agregar comentario\par
\par
"es bueno tener mensaje inicial"\par
\par
botn verde creat epull request\par
\par
esperar que test procesa y termine (caf\'e9)\par
(clic details)\par
\par
ver estado avances, pasos etc etc\par
...lento... est\'e1 cargando todas las ref...\par
\par
ahora m\'faltiples test, en paralelo\par
\par
en web ir a la carpeta dentro de github, workflows\par
\par
all\'ed est\'e1n los archivos de script\par
ahora solo\par
\par
tests.yaml\par
\par
para cada servicio un script (paralelo)\par
\par
todo dentro del mismo archivo es secuencial\par
\par
1) en vista del code inicial clic en lapiz, editor\par
\par
cambiar nombre en file y primera l\'ednea \par
tests-auth\par
\par
boton verde start commit, luego commit\par
\par
\par
click en path workflows, boton nuevo file\par
\par
\par
pegar code anterior y cambiar nombre de archivo y de script\par
\par
tests-orders y cambiar el directorio\par
commit change\par
\par
\par
seguimos con payments y tickets\par
\par
NO OLVIDAR AGREGAR EL SCRIPT TEST:CI !!! en code\par
\par
\par
(cambiar el branch de dev a master)\par
git switch master\par
git status (porsi)\par
\par
\par
\par
volver a editor\par
\par
orders/package.json\par
\par
pegar code de auth (no olvidar coma)\par
grabar y cerrar\par
\par
pasar a payments y tickets\par
\par
\par
en consola \par
git status\par
\par
(se\'f1ala los tres cambios)\par
\par
ATENTO AL FOLDER\par
\par
debe estar en ra\'edz! ticketing\par
\par
tiro de los cambios a local para poder avanzar\par
\par
git pull origin master\par
\par
subo los changes\par
\par
git push origin master\par
\par
no es malo chk en web los cambios, aun exsten los yaml\par
\par
y dentro de cada servicio los .json tienen mensaje de commit\par
\par
\par
ahora para realizar la prueba en paralelo debemos realizar cambio en code\par
y subir a la rama dev\par
\par
en orders agregamos un un console.log('iniciando');\par
\par
checar la rama dev\par
\par
git checkout dev\par
\par
y commiteo a dev, A DEV!!\par
\par
en web creo nuevo pull y debo ver el estado de los test en paralelo\par
\par
ojo\par
\par
si se pega m\'e1s de cinco minuto ir a test, cancelar con boton rojo\par
\par
ir a code, modificar \par
, commitear y realizar el pull\par
\par
cuando pasan todos los test estamos seguros\par
y podemos merge las ramas \par
\par
consideraciones:\par
estas pruebas paralelas no cvonsideran el detalle de nuestra arquitectura\par
los servicios son indpeendientes y conversar por medio de modulo common\par
pero es a traves de type no code\par
\par
por lo tanto cambios en un servicio no afectan a otros\par
se deben realizar solo a aquellos con cambios.\par
\par
a eso:\par
\par
\par
en consola volvemos a master\par
git switch master\par
\par
tiro los cambios \par
\par
git pull origin master\par
\par
en code\par
\par
vamos a la carpeta de workflows y modificamosa las yaml\par
\par
agrgando la condicion de si modifico algo dentro del code\par
se realice la prueba:\par
\par
name: tests-auth\par
on:\par
  pull_request:\par
    paths:               <-----------\par
      - 'auth/**'        <------------   \par
jobs:\par
  build:\par
    runs-on: ubuntu-latest\par
    steps:\par
      - uses: actions/checkout@v2\par
      - run: cd auth/ && npm install && npm run test:ci\par
\par
\par
\par
ahora comiteamos a MASTER MASTER!!\par
\par
luego cambiamso a DEV DEV DEV\par
\par
modificamos code comiteamos \par
\par
y vemos en web para realizar merge del pull\par
\par
\par
-------------------------\par
\par
registro en digitalocean\par
\par
creacion de proyecto e instalacion de doctl:\par
{{\field{\*\fldinst{HYPERLINK https://docs.digitalocean.com/reference/doctl/how-to/install/ }}{\fldrslt{https://docs.digitalocean.com/reference/doctl/how-to/install/\ul0\cf0}}}}\f0\fs22\par
\par
usar powershell\par
no funca en vscode\par
\par
conectando\par
\par
kubercloud nombre de cluster\par
\par
consola:\par
\par
doctl kubernetes cluster kubeconfig save kubercloud\par
Esperar unos segundos.. lenta la app\par
\par
se crean credenciales \par
\par
wow\par
\par
si \par
\par
 kubectl get nodes\par
\par
 me responden los tres nodos en DO cloud\par
\par
 yap, puedo tener varios contextos as\'ed q revisar y congi\par
\par
 kubectl config view\par
\par
 montonde datos, buscar:\par
\par
\par
contexts:\par
- context:\par
    cluster: do-sfo3-kubercloud\par
    user: do-sfo3-kubercloud-admin\par
  name: do-sfo3-kubercloud            <------\par
- context:\par
    cluster: docker-desktop\par
    user: docker-desktop\par
  name: docker-desktop                <-------\par
current-context: do-sfo3-kubercloud\par
\par
\par
existen dos, m\'e1quina local y el contexto en DO\par
\par
los nombres son la clave para cambiar entre \par
\par
\par
usar otro contexto es:\par
\par
kubectl config use-context docker-desktop\par
\par
por ej:\par
kubectl get nodes\par
\par
devuelve solo el locla\par
\par
NOTA::\par
\par
no vamos a implementar nada por este camino\par
\par
es solo para ver la conexi\'f3n y como arreglar o tocar un poquito\par
pero todo deebe ser por github, automatrizar\par
\par
}
 